# -*- coding: utf-8 -*-
"""ML0.1 intro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MTWAmrnsADR9ivbSD4UohYP2DyVsT3Io

# **Входной контроль**

**Цель работы**

Проверить знания базовых инструментов, которые используются для обращения с данными в проектах по машинному обучению - библиотек numpy, pandas, средств визуализации matplotlib, seaborn.

[ML_course/ML0.1 intro/](https://github.com/koroteevmv/ML_course/tree/main/ML0.1%20intro)

Среди базовых возможностей языка программирования Python при работе с анализом данных и машинным обучением чаще всего используются следующие:

индексирование массивов и срезы
генераторные выражения с условиями и циклами
анонимные функции
Среди средств библиотеки numpy чаще всего применяются следующие инструменты:

функции генерации массивов arange, linspace, logspace
функция генерации сетки mgrid
функции создания матриц diag, zeroes, ones
создание случайных значений - пакет random
форма массива - shape
изменение формы массива - reshape
оператор многоточия - ...
сложное индексирование
индексные маски
поэлементные операции
Библиотека pandas особенна полезна для манипуляции двумерными массивами информации. К самым часто используемым ее возможностям в машинном обучении относятся следующие:

сохранение и чтение файлов в формате csv, xls, xlsx
аналитические функции info, describe, head
итерация по строкам и столбцам, обращение к строкам и столбцам по номерам и индексам/названиям
объединения и соединения таблиц
агрегатные функции и группировка
замена отдельных значений в таблице в том числе по условию

**Задания для самостоятельного выполнения**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""1. С помощью массивов numpy создайте таблицу умножения."""

# Создаем массив от 1 до 10
array_1_to_10 = np.arange(1, 11)

multiplication_table = np.outer(array_1_to_10, array_1_to_10)

print("Таблица умножения:")
print(multiplication_table)

"""2. Создайте функцию, которая принимает как аргументы целое число N и первый элемент (вещественное число), и разность (вещественное число) и создает матрицу numpy по диагонали, которой располагаются первые N членов арифметической прогрессии."""

def arithmetic_progression_matrix(N, first_element, difference):
    # Генерируем массив с N членами арифметической прогрессии
    progression = np.arange(first_element, first_element + N * difference, difference)

    # Создаем диагональную матрицу с полученным массивом в качестве диагонали
    diagonal_matrix = np.diag(progression)

    return diagonal_matrix

N = 5  # Количество членов прогрессии
first_element = 2.5  # Первый элемент
difference = 3.0  # Разность арифметической прогрессии

result_matrix = arithmetic_progression_matrix(N, first_element, difference)
print("Матрица с диагональю из первых N членов арифметической прогрессии:")
print(result_matrix)

"""3. Сгенерируйте средствами numpy матрицу А 5 на 5, содержащую последовательные числа от 1 до 25. Используя срезы извлеките в плоский массив все нечетные элементы этой матрицы."""

# Создаем матрицу 5x5, содержащую числа от 1 до 25
matrix_A = np.arange(1, 26).reshape(5, 5)

print("Матрица А:")
print(matrix_A)

# Извлекаем все нечетные элементы в плоский массив с помощью срезов
odd_elements = matrix_A[matrix_A % 2 != 0]

print("\nВсе нечетные элементы матрицы А в плоском массиве:")
print(odd_elements)

"""4. Создайте двумерный массив, содержащий единицы на границе и нули внутри.

"""

# Задаем размеры массива (строки, столбцы)
rows, cols = 6, 8

array = np.zeros((rows, cols))

# Заполняем границы массива единицами
array[0, :] = 1  # верхняя граница
array[-1, :] = 1  # нижняя граница
array[:, 0] = 1  # левая граница
array[:, -1] = 1  # правая граница

print(array)

"""5. Создайте две матрицы размером (5,5). Одна матрица содержит 5 в шахматном порядке как в задаче домашнего задания, другая имеет треугольную форму содержащую 5 на основной диагонали и в позициях выше ее, а ниже все 0. Посчитайте их детерминант и найдите обратные матрицы."""

# Создание матрицы с числом 5 в шахматном порядке
matrix_chessboard = np.array([[5 if (i + j) % 2 == 0 else 0 for j in range(5)] for i in range(5)])
print("Матрица в шахматном порядке:")
print(matrix_chessboard)

"""6. С помощью pandas загрузите датасет для предсказания цены квартиры, прилагающийся к этой работе."""

# URL файла на GitHub
url = 'https://raw.githubusercontent.com/koroteevmv/ML_course/main/ML0.1%20intro/data.csv'

# Загрузка данных с помощью Pandas
db = pd.read_csv(url)
data = db
db

"""7. Выведите на экран несколько первых и несколько последний строк файла.


"""

print(db.head(3))
print(db.tail(3))

"""8. Выведите с помощью методов pandas основные количественные параметры датасета: количество строк и столбцов, тип данных каждого поля, количество значений в каждом столбце, шкала измерения каждого численного поля."""

print("Количество строк и столбцов в датасете:", db.shape)
print("\nТип данных каждого поля:\n", db.dtypes)
print("\nКоличество значений в каждом столбце:\n", db.count())
print("\nШкала измерения каждого численного поля:\n", db.describe())

"""9. Удалите из таблицы столбцы, содержащие идентификаторы, переименуйте все оставшиеся названия колонок на русском языке."""

db = db.drop(['Id'], axis=1)
db

db.columns=['Код района', 'Комнаты', 'Площадь', 'Площадь жилого помещения', 'Площадь кухни','Этаж','Кол-во этажей в доме','Год постройки дома','Экология1','Экология2','Экология3','Соц1','Соц2','Соц3','Здравоохранение1','Здравоохранение2', 'Магазины1', 'Магазины2','Цена']
db

"""10. Выведите отдельно столбец, содержащий цену, по номеру и названию. Выведите первую, десятую и предпоследнюю строку таблицы по номеру и по индексу."""

# ПО НАЗВАНИЮ
db['Цена']

# ПО НОМЕРУ
db[db.columns[-1]]

# Строки по индексам
db.iloc[0], db.iloc[9], db.iloc[-2]

# Строки по номеру
db.iloc[1], db.iloc[10], db.iloc[-2]

"""11. Выделите в отдельную таблицу последние десять строк. Уберите в ней столбец с ценой. Склейте ее с первоначальной таблицей при помощи append. Заполните отсутствующие значения цены средним по таблице."""

newdb_11 = db.iloc[-10:]
newdb_11 = newdb_11.drop(['Цена'], axis=1)
dbnew_11 = db.append(newdb_11)

mean = db['Цена'].mean()
dbnew_11['Цена'] = dbnew_11['Цена'].fillna(mean)
dbnew_11

"""12. Выделите пять последних колонок в отдельную таблицу. Удалите в ней строки, в которых цена ниже среднего. Присоедините эту таблицу к изначальной (выберите самый подходящий тип соединения)."""

new12 = db[db.columns[-5:]]
new12 = new12[new12.Цена >= mean]
new12

pd.concat([db,new12], sort = False,axis = 0)

"""13. Выведите таблицу, содержащую среднюю цену и количество квартир на каждом этаже из первоначального набора данных."""

result = db.groupby('Этаж').agg({'Цена': 'mean', 'Комнаты': 'count'}).reset_index()
result.columns = ['Этаж', 'Средняя цена', 'Количество квартир']
print(result)

"""14. Сохраните получившуюся таблицу в файлы формата csv и xlsx. Прочитайте их и убедитесь, что данные отображаются корректно."""

# Сохранение данных в CSV
result.to_csv('result.csv', index=False)

# Сохранение данных в XLSX
result.to_excel('result.xlsx', index=False)

# Чтение файлов CSV и XLSX
data_from_csv = pd.read_csv('result.csv')
data_from_xlsx = pd.read_excel('result.xlsx')

# Вывод данных из файлов CSV и XLSX для проверки
print("Данные из файла CSV:")
print(data_from_csv)

print("\nДанные из файла XLSX:")
print(data_from_xlsx)

"""17. Постройте круговую диаграмму для признака Rooms, иллюстрирующую количество квартир в процентах в зависимости от количества комнат. Сделайте сектор с наибольшим числом квартир выдвинутым."""

rooms_count = db['Комнаты'].value_counts()

# Сортировка значений по убыванию и выбор первого (наибольшего) значения
max_rooms = rooms_count.idxmax()

# Подготовка данных для диаграммы
labels = rooms_count.index.astype(str)
sizes = rooms_count.values
explode = [0.1 if room == max_rooms else 0 for room in labels]  # Выдвигаем сектор с наибольшим количеством квартир

# Построение круговой диаграммы
plt.figure(figsize=(8, 6))
plt.pie(sizes, labels=labels, autopct='%1.1f%%', explode=explode, startangle=140)
plt.axis('equal')  # Отображение в виде круга

plt.title('Процентное соотношение количества квартир по количеству комнат')
plt.show()

"""18. Постройте гистограмму по целевой переменной Price. Оцените визуально, по какой цене продаётся наибольшее количество квартир."""

# Построение гистограммы
plt.figure(figsize=(10, 6))
plt.hist(data['Price'], bins=30, color='skyblue', edgecolor='black')  # Выбор числа бинов (колонок) равным 30

# Добавление заголовка и подписей к осям
plt.title('Гистограмма цен на квартиры')
plt.xlabel('Цена')
plt.ylabel('Количество квартир')

# Отображение наиболее часто встречающейся цены (моды)
plt.axvline(x=data['Price'].mode()[0], color='red', linestyle='dashed', linewidth=1, label='Наибольшее количество квартир')

# Добавление легенды
plt.legend()

# Отображение гистограммы
plt.show()

"""19. Постройте диаграммы рассеяния для признаков Rooms, Square, HouseFloor, HouseYear в зависимости от целевой переменной Price в одной области figure. Оцените визуально, есть ли среди них такие, на которых разброс точек близок к линейной функции."""

# Создание области figure для диаграмм рассеяния
plt.figure(figsize=(15, 5))

# Диаграмма рассеяния для признака Rooms
plt.subplot(141)
plt.scatter(data['Rooms'], data['Price'], alpha=0.5)
plt.xlabel('Rooms')
plt.ylabel('Price')
plt.title('Зависимость цены от Rooms')

# Диаграмма рассеяния для признака Square
plt.subplot(142)
plt.scatter(data['Square'], data['Price'], alpha=0.5)
plt.xlabel('Square')
plt.ylabel('Price')
plt.title('Зависимость цены от Square')

# Диаграмма рассеяния для признака HouseFloor
plt.subplot(143)
plt.scatter(data['HouseFloor'], data['Price'], alpha=0.5)
plt.xlabel('HouseFloor')
plt.ylabel('Price')
plt.title('Зависимость цены от HouseFloor')

# Диаграмма рассеяния для признака HouseYear
plt.subplot(144)
plt.scatter(data['HouseYear'], data['Price'], alpha=0.5)
plt.xlabel('HouseYear')
plt.ylabel('Price')
plt.title('Зависимость цены от HouseYear')

"""20. Постройте ядерную оценку плотности целевой переменной Price. Оцените визуально, напоминает ли полученный график нормальное распределение. Постройте двумерную ядерную оценку плотности для целевой переменной Price и признака HouseFloor, затем оцените визуально на каких этажах и по какой цене продаётся основная масса квартир."""

# Построение ядерной оценки плотности для переменной Price
plt.figure(figsize=(8, 5))
sns.kdeplot(data['Price'], shade=True)
plt.title('Ядерная оценка плотности переменной Price')
plt.xlabel('Price')
plt.ylabel('Плотность')
plt.show()

# Построение двумерной ядерной оценки плотности для переменных Price и HouseFloor
sns.jointplot(x=data['Price'], y=data['HouseFloor'], kind='kde', cmap='viridis', fill=True)
plt.title('Двумерная ядерная оценка плотности для Price и HouseFloor')
plt.xlabel('Price')
plt.ylabel('HouseFloor')
plt.show()

"""21. Постройте ящиковую диаграмму признака Square. Оцените визуально имеются ли выбросы, и, если да, то начиная с какого размера площади значение признака можно считать выбросом."""

import seaborn as sns
import matplotlib.pyplot as plt

# Построение ящиковой диаграммы для признака Square
plt.figure(figsize=(8, 6))
sns.boxplot(x=data['Square'])
plt.title('Ящиковая диаграмма для признака Square')
plt.xlabel('Square')
plt.show()

"""**Какие структуры данных используются в Numpy? В чем их отличие от списков Python?**

Структуры данных в NumPy: основная структура данных в NumPy - это многомерный массив (ndarray). Они отличаются от списков Python тем, что ndarray предоставляет эффективное хранение и операции над массивами фиксированного типа, что позволяет выполнять операции над данными более быстро.

**Какие функции для генерации массивов использует Numpy?**

Функции для генерации массивов в NumPy: NumPy предоставляет функции, такие как np.array(), np.zeros(), np.ones(), np.arange(), np.linspace() и другие для генерации массивов различных размеров и содержимого.

**Какие способы предлагает Numpy для извлечения данных из массивов?**

Способы извлечения данных из массивов в NumPy: В NumPy используются индексация, срезы и булева индексация для извлечения данных из массивов.

**Что такое векторизация кода и почему это ускоряет работу программ?**

Векторизация кода в NumPy: Это процесс, при котором операции выполняются над целыми массивами данных, что позволяет избежать использования явных циклов. Это ускоряет работу программ за счет использования оптимизированных операций над массивами.

**Какие виды матричных операций реализованы в Numpy?**

Виды матричных операций в NumPy: NumPy предоставляет операции для умножения матриц, транспонирования, нахождения обратной матрицы, вычисления собственных значений и векторов и другие операции линейной алгебры.

**Какие функции используются для преобразования формы, размера и соединения массивов?**

Преобразование формы, размера и соединения массивов в NumPy: Для изменения формы и размера массивов используются методы reshape(), resize(), flatten() и другие. Для соединения массивов используются функции np.concatenate(), np.vstack(), np.hstack().

**Какие две главные структуры данных используются в pandas? В чем их отличие?**

Структуры данных в pandas: Основные структуры данных в pandas - это Series и DataFrame. Series - это одномерный массив с метками, а DataFrame - это двумерная структура данных, представляющая собой таблицу.

**Как происходит объединение двух таблиц в pandas?**

Объединение таблиц в pandas: Для объединения таблиц в pandas используются методы merge(), concat() и join() в зависимости от способа объединения и их структуры.

**Зачем нужны и как работают индексы в pandas.**

Индексы в pandas: Индексы в pandas помогают идентифицировать, извлекать и манипулировать данными. Они позволяют быстро доступать к данным и сохраняют порядок данных.

**Построение каких основных видов графиков используется при анализе данных в машинном обучении?**

Виды графиков для анализа данных в машинном обучении: Основные виды графиков включают гистограммы, диаграммы рассеяния, круговые диаграммы, ящиковые диаграммы, тепловые карты и другие.

**В чём разница между библиотеками matplotlib и seaborn? Каковы преимущества каждой из них?**

Разница между matplotlib и seaborn: Matplotlib - это библиотека для создания различных видов графиков, тогда как Seaborn - это надстройка над Matplotlib, предоставляющая удобные функции для создания статистических графиков с более простым синтаксисом.

**Как задать размер графика в matplotlib?**

Размер графика в matplotlib: Размер графика можно задать с помощью функции plt.figure(figsize=(width, height)).

**Как установить стили в seaborn?**

Установка стилей в seaborn: Стили в seaborn можно установить с помощью sns.set_style(), где можно выбрать стиль из доступных: "whitegrid", "darkgrid", "ticks", "white", "dark" и другие.

**Для чего используют подграфики subplots?**

Использование подграфиков subplots: Подграфики subplots позволяют создавать несколько графиков на одной общей плоскости, улучшая сравнение и визуализацию нескольких данных.

**Какие основные типы графиков реализованы в matplotlib? Что изображается на ящиковой диаграмме?**

Основные типы графиков в matplotlib: В matplotlib реализованы линейные графики, гистограммы, диаграммы рассеяния, ящиковые диаграммы и другие. На ящиковой диаграмме отображаются описательные статистики: медиана, квартили, выбросы.

**Как поменять палитру цветов у тепловой карты?**

Изменение палитры цветов у тепловой карты: Для изменения палитры цветов у тепловой карты в seaborn можно использовать функцию sns.heatmap() с аргументом cmap, указав нужную цветовую карту (например, 'viridis', 'coolwarm', 'magma' и т.д.).
"""